### 커피주문 시스템 설계

- 엔티티 목록
  - 메뉴
  - 유저
  - 주문
  - 결제
  - (포인트?) 유저에 합칠지 말지 고민 중,,

1. 메뉴
   - 메뉴 ID
   - 메뉴 이름
   - 메뉴 가격(결제 포인트)
2. 유저
   - 유저 ID
   - 유저 명
   - 유저 이름
   - 유저 보유 포인트 (Ref)
3. 주문 HEAD
   - 주문 ID
   - 주문한 유저 ID
   - 주문 금액
   - 주문 내용
   - 주문 상태(주문완료 / 주문취소 / 결제완료 / 결제취소)
   - 주문 일자
4. 주문 LINE
   - 주문 ID
   - 주문 SEQ(LINE_NO)
   - 메뉴 ID
   - 메뉴 선택 개수
   - 메뉴 하나 금액
   - 메뉴 개수 X 포인트 총 금액
   - 유저 ID (주문한 사람)
   - 주문 상태(주문완료 / 주문취소 / 결제완료 / 결제취소)
   - 주문 일자
5. 결제
   - 결제 ID
   - 주문 ID
   - 유저 ID
   - 결제 금액
   - 결제 상태(결제 완료/결제 취소)
   - 결제 일자
6. 포인트
   - 포인트 사용 내역 ID (충전 / 사용 / 소진)
   - 유저 ID
   - 포인트 Before
   - 포인트 금액
   - 포인트 After
   - 포인트 상태 (충전완료/충전취소/사용/소진)
   - 포인트 충전/차감 일시 (RGST_DT)

---
(작성 25.06.25)

동시성 문제와 데이터 일관성을 해결하기 위해서 위 DB 설계에서 문제될 수 있는 상황이 뭐가 있을까??
1. 1개의 주문에 대해서 2개의 결제가 들어왔을 때?
   - 네트워크 레벨에서의 결제 요청이 올바르게 가지 않았을 때, 재시도 중 2개의 요청이 서버로 들어온다면?


2. 한 유저가 동시에 두 곳에 결제를 한다면? 
   - (가장 가능성 높음)
   - 마지막 금액에서 두 개의 주문에 대한 결제가 올바르게 적용되어 두 개의 결제가 이뤄진 금액이 되어야함.
   - *** 공유자원이 현재 유저가 가지고 있는 포인트 금액이라고 할 때, 두 결제라는 멀티 스레드가 동시에 접근하는 것을 동기화하여, 순차적으로 혹은 Lock을 걸어서 진행해야할 필요가 있음. ***
   - => 찾아보니, 한 서버에서는 Transactional이나 락을 통해서 가능하지만, 두 개의 서버에서 동시에 이런 요청이 일어나면 동시성을 해결하기 위해 
     1. 낙관적 락, 비관적 락, Redis를 통한 Lock 방식 3가지가 있음.
     2. 이 모두를 구현해보자 한 번,,,
3. 포인트 충전이 이미 완료 되었는데, 또 똑같은 요청이 들어온다면???? 
   - 결제 완료 이후, 뒤로가기를 했을 때 다시 완료 버튼을 또 눌렀을 때???
   - 처음에 결제 하기 전, 포인트 사용 내역 ID + 1를 새로 하나 발급 받고 그 다음에 Insert.
   - 같은 요청이 또 들어온다면? 완료된 다음 포인트 사용내역 ID + 1로 이미 이뤄진 ID가 DB에 존재하면 실패???
     - 좀 더 고민해보기..


- 첫 번째 할 일 
  - 우선 JPARepository 랑 Entity를 만들고 테스트 코드를 통해 API 기능을 먼저 구현해보기 (데이터 생성, 실패, 성공 케이스)
- 그 다음 할 일
  - 동시성 문제가 발생하는 실패 케이스를 만들고 (Executor Service, CountDownLatch), 레디스나 DB Lock을 통해 목업 -> 실제 데이터까지 확인해보기`

---
### 동시성 문제 개념
https://dev-yujji.tistory.com/77#2.%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%EB%AC%B8%EC%A0%9C%20%EB%8C%80%ED%91%9C%EC%A0%81%20%EC%A6%9D%EC%83%81-1-1

### 재고 예제를 통한 참조
https://thalals.tistory.com/370#:~:text=%EB%8F%99%EC%8B%9C%EC%84%B1%20%EB%AC%B8%EC%A0%9C%EB%9E%80%2C%20%EB%8F%99%EC%9D%BC%ED%95%9C%20%ED%95%98%EB%82%98%EC%9D%98%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90%202%20%EC%9D%B4%EC%83%81%EC%9D%98,%EB%A1%9C%EC%A7%81%EC%9D%84%20%EC%B2%98%EB%A6%AC%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%8D%A8%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98%20%EC%A0%95%ED%95%A9%EC%84%B1%EC%9D%B4%20%EA%B9%A8%EC%A7%80%EB%8A%94%20%EB%AC%B8%EC%A0%9C%EB%A5%BC%20%EB%A7%90%ED%95%A9%EB%8B%88%EB%8B%A4.

1. 레이스 컨디션
- 2개 이상의 스레드가 공유 데이터에 액세스 할 수 있고, 동시에 변경하려 할 때 한 가지 동작이 상실될 수도 있는 상태
- 자바에서 제공하는 ExecutorService 와 CountDownLatch API를 통해 공유 자원 접근 시, 의도치 않은 결과가 나올 수 있음.

`ex) 재고 100개 -> 스레드 여러개를 통해 "재고 서비스"의 재고 개수를 100번 줄인다면?`

=> 재고가 0개가 아닌, 공유자원을 통한 접근으로 개수 감소가 올바르게 이뤄지지 않는 현상 발생.

---
